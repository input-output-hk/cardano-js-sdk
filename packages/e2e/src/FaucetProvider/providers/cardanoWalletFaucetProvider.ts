// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { Provider, HealthCheckResponse } from '../../../core';
import { WalletServer, ApiNetworkInformationSyncProgressStatusEnum,
         AddressWallet, TransactionWallet, ApiTransactionStatusEnum } from 'cardano-wallet-js'
import { FaucetProvider, FaucetRequestResult, FaucetRequestTransactionStatus, } from '../'
import * as timer from "minimal-timer"

// Constnats
const FAUCET_PASSPHRASE:  string = "faucet";
const FAUCET_WALLET_NAME: string = "faucet";

/**
 * Cardano Wallet implementation of the faucet provider. This provider utlizes the Cardano Wallet HTTP service
 * to construct, sign, submit and track the transaction generated by the faucet.
 */
class CardanoWalletFaucetService implements FaucetProvider {

  _serviceUrl:     string  = "";
  _seedPhrases:    string  = "";
  _faucetWalletId: string= "";
  _walletServer:   WalletServer;
 
  /**
   * Initializes a new instance of the CardanoWalletFaucetService class.
   * 
   * @param url The cardano wallet server REST endpoint.
   * @param seedPhrases The seedphrases of the faucet wallet.
   */
  constructor(url: string, seedPhrases: string) {

    this._serviceUrl  = url;
    this._seedPhrases = seedPhrases;
  }

  /**
   * Request tAda to be transferred to the given address.
   * 
   * @param address The address where the tAda must be deposited.
   * @param amount  The amount of tAda to be debposited (in lovelace).
   * @param confirmation The number of blocks on top of our transaction needed to consider the transaction confirmed.
   * @param timeout The time we are willing to wait (in milliseconds) for the faucet request transaction to be confirmed.
   * 
   * @throws If the transaction generated by this request is not confirmed on time.
   */
  public async request(address: string, amount: number, confirmations: number, timeout: number): Promise<FaucetRequestResult> {
 
    let faucetWallet = await this._walletServer.getShelleyWallet(this._faucetWalletId);
    
    let receiverAddress = [new AddressWallet(address)];
    let amounts = [amount];

    const time = timer();
    time.start();

    let transaction: TransactionWallet = await faucetWallet.sendPayment(FAUCET_PASSPHRASE, receiverAddress, amounts);

    while (transaction.depth?.quantity < confirmations && time.elapsedTime() < timeout)
      transaction = await faucetWallet.getTransaction(transaction.id);

    if (time.elapsedTime() >= timeout)
      throw `The transaction ${transaction.id} was not confirmed on time`;

    return {
      txId: transaction.id,
      status: this.mapStatus(transaction.status),
      depth: transaction.depth?.quantity,
      time: transaction.inserted_at?.time
    }
  }

  /**
   * Starts the provider.
   */
  public async start(): Promise<void> {

    const walletInfo = {
      name: FAUCET_WALLET_NAME,
      mnemonic_sentence: [...this._seedPhrases],
      passphrase: FAUCET_PASSPHRASE };

      this._walletServer = WalletServer.init(this._serviceUrl);

      let axiosResponse = await this._walletServer.walletsApi.postWallet(walletInfo);
      this._faucetWalletId = axiosResponse.data.id;

      return;
  }
 
  /**
   * Closes the provider.
   */
  public async close(): Promise<void> {

    this._faucetWalletId = "";
    return;
  }

  /**
   * Performs a health check on the provider.
   * 
   * @return A promise with the healthcheck reponse.
   */
  public async healthCheck(): Promise<HealthCheckResponse> {

    const networkInfo = await this._walletServer.getNetworkInformation();

    return { ok: networkInfo.sync_progress.status === ApiNetworkInformationSyncProgressStatusEnum.Ready 
      && this._faucetWalletId !== "" };
  }

  /**
   * Converts the cardano wallet transaction result enum to our FaucetRequestTransactionStatus enum.
   * @param status The cardano wallet enum to be converted.
   * 
   * @returns The FaucetRequestTransactionStatus equivalent enum value.
   */
  private mapStatus(status: ApiTransactionStatusEnum) : FaucetRequestTransactionStatus {
    let mappedStatus: FaucetRequestTransactionStatus = FaucetRequestTransactionStatus.Expired;
    switch (status) {
      case ApiTransactionStatusEnum.Expired:
        mappedStatus = FaucetRequestTransactionStatus.Expired;
        break;
      case ApiTransactionStatusEnum.InLedger:
        mappedStatus = FaucetRequestTransactionStatus.InLedger;
        break;
      case ApiTransactionStatusEnum.Pending:
        mappedStatus = FaucetRequestTransactionStatus.Pending;
        break;
    }

    return mappedStatus;
  }
}