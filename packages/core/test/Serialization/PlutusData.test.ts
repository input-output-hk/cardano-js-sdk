import { Cardano, ConstrPlutusData, PlutusData, PlutusList, PlutusMap } from '../../src';
import { HexBlob } from '@cardano-sdk/util';

describe('PlutusData', () => {
  it('round trip serializations produce the same core type output', () => {
    const plutusData: Cardano.PlutusData = 123n;
    const fromCore = PlutusData.fromCore(plutusData);
    const cbor = fromCore.toCbor();
    const fromCbor = PlutusData.fromCbor(cbor);
    expect(fromCbor.toCore()).toEqual(plutusData);
  });

  it('converts inline datum that fails to deserialize with CML', () => {
    // tx: https://preprod.cexplorer.io/tx/32d2b9062680c7ef5673114abce804d8b854f54440518e48a6db3e555f3a84d2
    // parsed datum: https://preprod.cexplorer.io/datum/f20e5a0a42a9015cd4e53f8b8c020e535957f782ea3231453fe4cf46a52d07c9
    const cbor = HexBlob(
      'd8799fa3446e616d6548537061636542756445696d6167654b697066733a2f2f7465737445696d616765583061723a2f2f66355738525a6d4151696d757a5f7679744659396f66497a6439517047614449763255587272616854753401ff'
    );
    expect(() => PlutusData.fromCbor(cbor)).not.toThrowError();
  });

  describe('Integer', () => {
    it('can encode a positive integer', () => {
      const data = PlutusData.newInteger(5n);
      expect(data.toCbor()).toEqual('05');
    });

    it('can encode a negative integer', () => {
      const data = PlutusData.newInteger(-5n);
      expect(data.toCbor()).toEqual('24');
    });

    it('can encode an integer bigger than unsigned 64bits', () => {
      const data = PlutusData.newInteger(18_446_744_073_709_551_616n);
      expect(data.toCbor()).toEqual('c249010000000000000000');
    });

    it('can encode a negative integer bigger than unsigned 64bits', () => {
      const data = PlutusData.newInteger(-18_446_744_073_709_551_616n);
      expect(data.toCbor()).toEqual('3bffffffffffffffff');
    });

    it('can decode a positive integer', () => {
      const data = PlutusData.fromCbor(HexBlob('05'));
      expect(data.asInteger()).toEqual(5n);
    });

    it('can decode a negative integer', () => {
      const data = PlutusData.fromCbor(HexBlob('24'));
      expect(data.asInteger()).toEqual(-5n);
    });

    it('can decode an integer bigger than unsigned 64bits', () => {
      const data = PlutusData.fromCbor(HexBlob('c249010000000000000000'));
      expect(data.asInteger()).toEqual(18_446_744_073_709_551_616n);
    });

    it('can decode a negative integer bigger than unsigned 64bits', () => {
      const data = PlutusData.fromCbor(HexBlob('3bffffffffffffffff'));
      expect(data.asInteger()).toEqual(-18_446_744_073_709_551_616n);
    });
  });

  describe('Bytes', () => {
    it('can encode a small byte string (less than 64 bytes)', () => {
      const data = PlutusData.newBytes(new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]));
      expect(data.toCbor()).toEqual('46010203040506');
    });

    it('can decode a small byte string (less than 64 bytes)', () => {
      const data = PlutusData.fromCbor(HexBlob('46010203040506'));
      expect(HexBlob.fromBytes(data.asBoundedBytes()!)).toEqual('010203040506');
    });

    it('can encode a big byte string (more than 64 bytes)', () => {
      const payload = new Uint8Array([
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08
      ]);

      const data = PlutusData.newBytes(payload);
      expect(data.toCbor()).toEqual(
        '5f584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708ff'
      );
    });

    it('can decode a big byte string (more than 64 bytes)', () => {
      const payload = [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08
      ];

      const data = PlutusData.fromCbor(
        HexBlob(
          '5f584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708ff'
        )
      );
      expect([...data.asBoundedBytes()!]).toEqual(payload);
    });
  });

  describe('List', () => {
    it('can encode simple plutus list', () => {
      const data = new PlutusList();

      data.add(PlutusData.newInteger(1n));
      data.add(PlutusData.newInteger(2n));
      data.add(PlutusData.newInteger(3n));
      data.add(PlutusData.newInteger(4n));
      data.add(PlutusData.newInteger(5n));

      expect(data.toCbor()).toEqual('9f0102030405ff');
    });

    it('can encode a list of plutus list', () => {
      const innerList = new PlutusList();

      innerList.add(PlutusData.newInteger(1n));
      innerList.add(PlutusData.newInteger(2n));
      innerList.add(PlutusData.newInteger(3n));
      innerList.add(PlutusData.newInteger(4n));
      innerList.add(PlutusData.newInteger(5n));

      const outer = new PlutusList();

      outer.add(PlutusData.newInteger(1n));
      outer.add(PlutusData.newInteger(2n));
      outer.add(PlutusData.newList(innerList));
      outer.add(PlutusData.newList(innerList));
      outer.add(PlutusData.newInteger(5n));

      expect(outer.toCbor()).toEqual('9f01029f0102030405ff9f0102030405ff05ff');
    });
  });

  describe('Map', () => {
    it('can encode simple plutus map', () => {
      const data = new PlutusMap();

      data.insert(PlutusData.newInteger(1n), PlutusData.newInteger(2n));

      expect(data.toCbor()).toEqual('a10102');
    });
  });

  describe('Constr', () => {
    it('can encode simple Constr', () => {
      const args = new PlutusList();
      args.add(PlutusData.newInteger(1n));
      args.add(PlutusData.newInteger(2n));
      args.add(PlutusData.newInteger(3n));
      args.add(PlutusData.newInteger(4n));
      args.add(PlutusData.newInteger(5n));

      const data = new ConstrPlutusData(0n, args);

      expect(data.toCbor()).toEqual('d8799f0102030405ff');
    });
  });
});
